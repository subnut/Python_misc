<html>
<head>
<title>Python_misc</title>
<link rel="stylesheet" href="prism.css">
</head>
<body bgcolor="#F5F2F0" link="#1F00FF" vlink="#1F00FF">
<br>
<ul>
<li><a href="#0">insertion sort</a></li>
<li><a href="#1">code_golf_palindrome_letters_only</a></li>
<li><a href="#2">f</a></li>
<li><a href="#3">f_buggy</a></li>
<li><a href="#4">SimpleHTTPServer_pyftpdlib</a></li>
<li><a href="#5">f_ultimate</a></li>
<li><a href="#6">ansi_color_print</a></li>
<li><a href="#7">shell_sort</a></li>
<li><a href="#8">bubble sort</a></li>
<li><a href="#9">autocomplete_example</a></li>
<li><a href="#10">aufbau</a></li>
<li><a href="#11">MonitoTileX</a></li>
<li><a href="#12">run_command</a></li>
<li><a href="#13">quicksort</a></li>
</ul>
<br><br>
<a id="0"></a>
<br><br>
insertion sort<br>
<pre>
<code class=" language-python">## insertion sort

def insertion(l):
    for i in range(1,len(l)):
        for j in range(i,0,-1):
            if l[j]>=l[j-1]:
                break
            l[j],l[j-1]=l[j-1],l[j]
    return l

#print(insertion([int(x) for x in input("Enter the list of numbers separated by spaces: ").split()]))

def foo(l):
    l=insertion(l)
    for i in range(len(l)):
        if l[i]==int(l[i]): l[i]=int(l[i])
    return l

print(foo([float(x) for x in input("Enter the values separated by spaces: ").split()]))<br>
</code>
</pre>
<a id="1"></a>
<br><br>
code_golf_palindrome_letters_only<br>
<pre>
<code class=" language-python">## Source: https://stringlabs.io/codegolf/challenge/palindromicallyspeaking

''' Write a function called hannah that takes in a string and returns
    whether or not the letters (and only the letters) in that sentence are a palindrome (case insensitive).
    Your function should return a boolean.  '''

## Best submission: 70 bytes
## My answer: 68 bytes 

def hannah(s):
	l=[x for x in s if x.isalpha()]
	return l==l[::-1]<br>
</code>
</pre>
<a id="2"></a>
<br><br>
f<br>
<pre>
<code class=" language-python">##  Simple and effective(?)
##  Cheers  :D

import threading as t
def f():
    while True:
        t.Thread(target=f).start()
        f()

f()<br>
</code>
</pre>
<a id="3"></a>
<br><br>
f_buggy<br>
<pre>
<code class=" language-python">import os,threading as t

def f():
    while True:
        os.system('python f_buggy.py')
        t.Thread(target=f).start()
        f()

f()<br>
</code>
</pre>
<a id="4"></a>
<br><br>
SimpleHTTPServer_pyftpdlib<br>
<pre>
<code class=" language-python">''' 
This is not actually a Python program
But it is, undeniably, an amazing piece of code
N.B. Python2 must be installed on the machine

At the terminal, cd into the folder you want
run the following command

python2 -m SimpleHTTPServer 8080

then, it will set up a simple HTTP server on port 8080
sharing the contents of the folder

Explanation of the code -

This command executes Python2
and imports the embedded Python2 module SimpleHTTPServer
which runs an HTTP server on port 8080 of the machine
on the directory this code is executed in

Simple way to quickly send some files :D


also, for ftp server (again python2)

pip install pyftpdlib
python2 -m pyftpdlib --help

see the help and configure as required :D

'''<br>
</code>
</pre>
<a id="5"></a>
<br><br>
f_ultimate<br>
<pre>
<code class=" language-python">import os,sys,threading

def f():
    while True:
        os.system('python '+os.path.abspath(sys.argv[0]))
        threading.Thread(target=f).start()
        f()

f()<br>
</code>
</pre>
<a id="6"></a>
<br><br>
ansi_color_print<br>
<pre>
<code class=" language-python">def colorPrint(string,colorArgs,end='\n'):
    import sys
    fore=back=None
    try: fore=colorArgs[0]
    except: pass
    try: back=colorArgs[1]
    sys.stdout.write('\033[38;5;'+str(foreColor)+'m'+string+'')
<br>
</code>
</pre>
<a id="7"></a>
<br><br>
shell_sort<br>
<pre>
<code class=" language-python">## shell_sort

def insertion(l,step):
    for i in range(1,len(l),step):
        for j in range(i,0,-step):
            if l[j]>=l[j-step]:
                break
            l[j],l[j-step]=l[j-step],l[j]
    return l

def control(l):
    step=len(l)//2
    while True:
        if step<1: break
        l=insertion(l,step)
        step-=1
    return l

#print(control([int(x) for x in input("Enter the list of numbers separated by spaces: ").split()]))

def foo(l):
    l=control(l)
    for i in range(len(l)):
        if l[i]==int(l[i]): l[i]=int(l[i])
    return l

print(foo([float(x) for x in input("Enter the values separated by spaces: ").split()]))<br>
</code>
</pre>
<a id="8"></a>
<br><br>
bubble sort<br>
<pre>
<code class=" language-python">## bubble sort

def bubble(l):
    for i in range(len(l),1,-1):
        for j in range(1,i):
            if l[j-1]>l[j]:
                l[j],l[j-1]=l[j-1],l[j]
    return l

#print(bubble([int(x) for x in input("Enter the list of numbers separated by spaces: ").split()]))

def foo(l):
    l=bubble(l)
    for i in range(len(l)):
        if l[i]==int(l[i]): l[i]=int(l[i])
    return l

print(foo([float(x) for x in input("Enter the values separated by spaces: ").split()]))<br>
</code>
</pre>
<a id="9"></a>
<br><br>
autocomplete_example<br>
<pre>
<code class=" language-python">import readline

addrs = ['angela@domain.com', 'michael@domain.com', 'david@test.com']

def completer(text, state):
    options = [x for x in addrs if x.startswith(text)]
    try:
        return options[state]
    except IndexError:
        return None

readline.set_completer(completer)
readline.parse_and_bind("tab: complete")

while 1:
    a = input("> ")
    print("You entered", a)
<br>
</code>
</pre>
<a id="10"></a>
<br><br>
aufbau<br>
<pre>
<code class=" language-python">## Aufbau
class Aufbau:
    def __init__(self,args=None):
        if args != None:
            if type(args) == type(str()):
                self.globalOrbitalList = args
                self.generateFromOrbitalList()
            if type(args) == type(int()):
                self.globalLastOrbit = args
                self.generateFromLastOrbit()

    def generateFromOrbitalList(self,orbitalList=None):
        if not orbitalList:
            try: orbitalList = self.globalOrbitalList
            except NameError: raise NameError("Orbital list not defined")
        orbitList   = [None]
        returnList  = []
        for orbitNo in range(1,2*len(orbitalList)+1):
            orbitList.append(str(orbitNo))
        for currentEnergy in range(1,2*len(orbitalList)+1):
            for currentOrbitEnergy in range(len(orbitList)):
                for currentOrbitalEnergy in range(currentOrbitEnergy):
                    if currentOrbitEnergy + currentOrbitalEnergy == currentEnergy:
                        returnList.append(orbitList[currentOrbitEnergy]+orbitalList[currentOrbitalEnergy])
                        break
                    else:
                        continue
                    break
        self.globalOutput = returnList
        self.globalOrbitList = orbitList

    def generateFromLastOrbit(self,lastOrbit=None):
        if not lastOrbit:
            try: lastOrbit = self.globalLastOrbit
            except NameError: raise NameError('Last orbit number not specified')
        

    def printList(self):
        for orbital in self.globalOutput:
            print(orbital)


    def printChart(self):
        for orbit in self.globalOrbitList:
            for orbital in self.globalOutput:
                if orbital[:-1] == str(orbit):
                    if len(self.globalOrbitList[-1]) > 1 and len(orbital) < 3 :
                        print('0' + orbital,end=' ')
                    else:
                        print(orbital,end=' ')
            if orbit and int(orbit) > len(self.globalOrbitalList):
                print('...',end=' ')
            print()
        print()


def main():
    print("""What do you have?
    1. Orbital List
    2. Last Orbit number""")
    userInput = input("Enter your option: ")
    if userInput not in ('1','2'):
        print("Invalid option!")
        return
    elif userInput == '1': userInput = input("Please enter the order of the orbitals WITHOUT whitespace: ")
    elif userInput == '2': userInput = input("Please enter the last orbit number: ")
    userObject = Aufbau(userInput)
    print("""What do you want to print?
    1. Aufbau Chart
    2. Aufbau List""")
    userInput = input("Enter your option: ")
    if userInput not in ('1','2'):
        print("Invalid option!")
        return
    elif userInput == '1': userObject.printChart()
    elif userInput == '2': userObject.printList()

if __name__ == '__main__':
    print("To quit, press Ctrl-C anytime")
    while True:
        try:
            main()
        except KeyboardInterrupt:
            print("\nExiting ...")
            break
<br>
</code>
</pre>
<a id="11"></a>
<br><br>
MonitoTileX<br>
<pre>
<code class=" language-python">## MonitoTileX
## Yes, the X stands for X

def run(command):
    from subprocess import PIPE,Popen
    process=Popen(["sh","-c",command],stdout=PIPE,stderr=PIPE,text=True)
    stdout,stderr=process.communicate()
    exitcode=process.returncode
    return {'stdout':stdout,'stderr':stderr,'exitcode':exitcode}

def get_loginid():
    for string in run("loginctl")['stdout'].lower().split('\n'):
        if string.find(getlogin()) != -1 & string.find("tty") == -1:
            return string.split()[0]
    else:
        print("No non-tty logins of this user has been found. Please login into a X session.")
        exit(1)

def get_session_type():
    return run("loginctl show-session "+get_loginid()+" -p Type")['stdout'].split('=')[1].split('\n')[0]

def check_xrandr():
    xrandr_code = run("xrandr")['exitcode']
    if xrandr_code == 0: return True
    elif xrandr_code == 127: print("command 'xrandr' not found \nPlease install the package which includes this command")
    elif xrandr_code == 1: print("xrandr exited with exit code 1\nAre you on a X session? This program only runs inside an X session")
    else: print("Unknown error while running 'xrandr'")
    exit(1)

def check_readline():
    try: import readline
    except ModuleNotFoundError:
        exitcode = run("python -m pip install readline")['exitcode']
        if exitcode != 0: print("Module 'readline' was not found. Please install."); exit(1); return False
    return True

def check():
   if (tuple(version_info)[0]==3) & (platform=='linux') & (get_session_type()=='x11') & check_xrandr() & check_readline():
        return True
   else:
        if tuple(version_info)[0]!=3: print("Python v3 needed")
        elif platform != 'linux': print("Only linux is supported")
        elif get_session_type()=='wayland': print("Wayland is not supported")
        elif get_session_type()!="x11": print("Needs X11 session")
        elif not check_xrandr(): pass
        else: print("Unknown error")
        return False 


def my_completer_helper(inputText,commands,loopState):
    matchList = [x for x in commands if x.startswith(inputText)]
    
    if len(matchList)==0:
        if loopState > 0: return None
        for l in range(1,len(inputText)):
            matches = [x for x in commands if x.startswith(inputText[:-l])]
            if len(matches) > 0:
                return matches[0]+' '

    if len(matchList)==1:
        if loopState==0: return matchList[0]+' '
        else: return None
    
    else:
        try: return matchList[loopState]
        except IndexError: return None




def my_completer_function(inputText, loopState):
    firstCommands = ['do','orient','status','quit']
    monitors = [ x for x in run("xrandr -q | grep ' connected' | cut -d' ' -f1")['stdout'].split('\n') if len(x) > 0 ]
    directionOf = [ 'left', 'right', 'top', 'bottom' ]
    alignTo = { 
                'left':('top', 'bottom'),
                'right':('top', 'bottom'),
                'top':('left', 'right'),
                'bottom':('left', 'right')
              }
    if inputText.count(' ') == 0:
        return my_completer_helper(inputText,firstCommands,loopState)
    if inputText.count(' ') == 1:
        firstCommand = inputText.split()[0]
        availableCommands = 
        return my_completer_helper(,monitors,loopState)
    

def currentlyConnected(monitors):
    return "Currently connected monitors are: "+monitorListToString(monitors)

def monitorListToString(monitors):
    monitorString = ""
    for x in monitors:
        monitorString += x + " "
    return monitorString





def main_loop():
    userInput = input('\n> ')
    monitors = [ x for x in run("xrandr -q | grep ' connected' | cut -d' ' -f1")['stdout'].split('\n') if len(x) > 0 ]
    

    
    if userInput == "status":
        print(currentlyConnected(monitors))
    if userInput in ("quit","q"):
        return False
    return True

def main():
    if not check(): print("Unknown Error"); exit(1); return False
    import readline
    readline.set_completer(my_completer_function)
    readline.parse_and_bind("tab: complete")
    monitors = [ x for x in run("xrandr -q | grep ' connected' | cut -d' ' -f1")['stdout'].split('\n') if len(x) > 0 ]
    print("""Welcome to Monitotilex!
Enter 'q' or 'quit' to exit
{}
To get this list of connected monitors, run 'status' anytime

Valid commands are of the syntax:   
    do <monitor-name-1> <left|right|top|bottom> <monitor-name-2> <aligned-to-side>
    orient <monitor-name> <normal|left-side-down|right-side-down|upside-down>
And are interpreted as:
    <monitor-name-1> is <left|right|top|bottom> of <monitor-name-2> and aligned to the <aligned-to-side> side of <monitor-name-2>
    <monitor-name> has been kept in the position <normal|left-side-down|right-side-down|upside-down>. So adjust the display accordingly.

P.S.: Tab-completion is available at every step""".format(currentlyConnected(monitors)))
    loop = True
    while loop:
        loop = main_loop()
    exit(0)




try: from sys import version_info,platform; from os import getlogin
except ModuleNotFoundError: print("Please insure that the following modules are available:\nsys, os"); exit(1)
else: pass

if (__name__=="__main__") & check(): main()


# To-do
""" wrong command -> suggest
command interpreter -> input().split()
main logic
mirror command (mirror <mon1> <mon2>)
"""
<br>
</code>
</pre>
<a id="12"></a>
<br><br>
run_command<br>
<pre>
<code class=" language-python">## Used to run commands input as a single string using "sh -c"

def run(command):
    from subprocess import PIPE,Popen
    process=Popen(["sh","-c",command],stdout=PIPE,stderr=PIPE,text=True)
    stdout,stderr=process.communicate()
    exitcode=process.returncode
    return {'stdout':stdout,'stderr':stderr,'exitcode':exitcode}

<br>
</code>
</pre>
<a id="13"></a>
<br><br>
quicksort<br>
<pre>
<code class=" language-python">## quicksort

def quicksort(l):
    if len(l)>1:
        p=l[0]      #pivot
        less=[]
        more=[]
        i=0
        while True:
            try:
                if l[i]<p: less.append(l.pop(i))
                if l[i]>p: more.append(l.pop(i))
                if l[i]==p: i+=1
            except IndexError:
                break
        less=quicksort(less)
        more=quicksort(more)
        l=less+l+more
    return l

#print(quicksort([int(x) for x in input("Enter the list of numbers separated by spaces: ").split()]))

def foo(l):
    l=quicksort(l)
    for i in range(len(l)):
        if l[i]==int(l[i]): l[i]=int(l[i])
    return l

print(foo([float(x) for x in input("Enter the values separated by spaces: ").split()]))<br>
</code>
</pre>
<script src="prism.js"></script>
</body>
</html>